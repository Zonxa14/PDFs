
<!-- saved from url=(0069)https://bisqwit.iki.fi/story/howto/bitmath/#MulUnsignedMultiplication -->
<html><script data-dapp-detection="">
(function() {
  let alreadyInsertedMetaTag = false

  function __insertDappDetected() {
    if (!alreadyInsertedMetaTag) {
      const meta = document.createElement('meta')
      meta.name = 'dapp-detected'
      document.head.appendChild(meta)
      alreadyInsertedMetaTag = true
    }
  }

  if (window.hasOwnProperty('web3')) {
    // Note a closure can't be used for this var because some sites like
    // www.wnyc.org do a second script execution via eval for some reason.
    window.__disableDappDetectionInsertion = true
    // Likely oldWeb3 is undefined and it has a property only because
    // we defined it. Some sites like wnyc.org are evaling all scripts
    // that exist again, so this is protection against multiple calls.
    if (window.web3 === undefined) {
      return
    }
    __insertDappDetected()
  } else {
    var oldWeb3 = window.web3
    Object.defineProperty(window, 'web3', {
      configurable: true,
      set: function (val) {
        if (!window.__disableDappDetectionInsertion)
          __insertDappDetected()
        oldWeb3 = val
      },
      get: function () {
        if (!window.__disableDappDetectionInsertion)
          __insertDappDetected()
        return oldWeb3
      }
    })
  }
})()</script><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Synthesizing arithmetic operations using bit-shifting tricks</title>
  <link rel="stylesheet" type="text/css" href="./bitwise_files/css" title="normal">
  <script type="text/javascript" src="./bitwise_files/mktree.js"></script>
 </head>
 <body data-gr-c-s-loaded="true">


<h1><a name="BitMathematicsCookbook"></a>Bit mathematics cookbook</h1><div class="deeper">
<small>By <a class="extlink" id="i1EE48DDA" href="http://iki.fi/bisqwit/">Joel Yliluoma</a>, January 2014</small>
<p>How to implement various arithmetic and logical operations on platforms
without native support for those operations.
</p><p>Two's complement is assumed.
</p><p></p><div class="toc">Table of contents [<span onclick="expandTree(&#39;wikitoc1&#39;)" class="mktreecmd">expand all</span>] [<span onclick="collapseTree(&#39;wikitoc1&#39;)" class="mktreecmd">collapse all</span>]<br>
<ul class="mktree" id="wikitoc1"><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#AddAndSub">ADD and SUB
</a><ul><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#AdditionWithoutCarry">Addition without carry
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingSubtraction">Using subtraction
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingBitwiseOperationsWithXor">Using bitwise operations, with XOR
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#Other">Other
</a></li></ul></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#AdcAdditionWithCarry">ADC: Addition with carry
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingAdditionComparison">Using addition &amp; comparison
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingAdditionWithLargerOperands">Using addition with larger operands
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingBitwiseOperationsWithoutXor">Using bitwise operations, without XOR
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingBitwiseShiftWithCarryOrRotateWithCarryOperations">Using bitwise shift-with-carry or rotate-with-carry operations
</a></li></ul></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#AdditionOfLargerIntegersThanNativeRegisterSize">Addition of larger integers than native register size
</a></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#SubtractionWithoutCarry">Subtraction without carry
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingAddition">Using addition
</a></li></ul></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#SbcSubtractionWithCarry">SBC: Subtraction with carry
</a></li></ul></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#SgnTestingIfValueIsNegative">SGN / Testing if value is negative
</a></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#Neg">NEG
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#ArithmeticNegation">Arithmetic negation
</a></li></ul></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#Not">NOT
</a><ul><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#LogicalNegationNotInvertOperation">Logical negation (NOT / invert operation)
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingXor">Using XOR
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingSubtraction_2">Using subtraction
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingArithmeticNegation">Using arithmetic negation
</a></li></ul></li></ul></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#AndAndOr">AND and OR
</a><ul><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#LogicalBitWiseAnd">Logical bit-wise AND
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingNotAndOr">Using NOT and OR
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#DoingItBitByBit">Doing it bit-by-bit
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#BitByBitUsingArithmeticOperationsOnly">Bit-by-bit using arithmetic operations only
</a></li></ul></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#LogicalBitWiseOr">Logical bit-wise OR
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingNotAndAnd">Using NOT and AND
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#DoingItBitByBit_2">Doing it bit-by-bit
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#BitByBitUsingArithmeticOperationsOnly_2">Bit-by-bit using arithmetic operations only
</a></li></ul></li></ul></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#Xor">XOR
</a><ul><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#LogicalBitWiseXor">Logical bit-wise XOR
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingNotOrAndAnd">Using NOT, OR and AND
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#DoingItBitByBit_3">Doing it bit-by-bit
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#BitByBitUsingArithmeticOperationsOnly_3">Bit-by-bit using arithmetic operations only
</a></li></ul></li></ul></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#ShlLslAslSlLogicalBinaryArithmeticBitShiftToLeftBy%201">SHL/LSL/ASL/SL: Logical/binary/arithmetic bit-shift to left by 1
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#LargerSizeBitShiftingToLeft">Larger-size bit-shifting to left
</a></li></ul></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#ShrLsrSrLogicalBinaryBitShiftToRightBy%201">SHR/LSR/SR: Logical/binary bit-shift to right by 1
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#WithoutDivisions">Without divisions
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#LargerSizeBitShiftingToRight">Larger-size bit-shifting to right
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#WhenYouHaveArithmeticBitShiftToTheRight">When you have arithmetic bit-shift to the right
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#WhenYouDoNotHaveAnyBitOperations">When you do not have any bit-operations
</a></li></ul></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#AsrSraArithmeticBitShiftToTheRight">ASR/SRA: Arithmetic bit-shift to the right
</a><ul><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#WhenShiftingBy%201Bit">When shifting by 1 bit
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#WhenShiftingUsesCarry">When shifting uses carry
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#UsingBitTest">Using bit-test
</a></li></ul></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#WhenShiftingByNBits">When shifting by N bits
</a></li></ul></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#MulUnsignedMultiplication">MUL: Unsigned multiplication
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#MultiplicationWithoutMultiplicationOperations">Multiplication without multiplication operations
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#MultiplicationWithoutAnyBitOperations">Multiplication without any bit-operations
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#MultiplicationOfLargerIntegers">Multiplication of larger integers
</a></li></ul></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#MliImulMuliSignedMultiplication">MLI/IMUL/MULI: Signed multiplication
</a></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#DivAndModDivisionAndModulo">DIV and MOD: Division and modulo
</a><ul><li class="liClosed"><span class="bullet">&nbsp;</span><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#Explanation">Explanation
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#ImplementingWithAStackWithoutBitShiftOperations">Implementing with a stack, without bit-shift operations
</a></li></ul></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#DviIdivDiviSignedDivision">DVI/IDIV/DIVI: Signed division
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#MdiImodModiSignedModuloRemainder">MDI/IMOD/MODI: Signed modulo (remainder)
</a></li></ul></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#Exponentiation">Exponentiation
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#ExponentiationWithoutAnyBitOperations">Exponentiation without any bit-operations
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#OptimizationForConstantExponents">Optimization for constant exponents
</a></li></ul></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#Comparisons">Comparisons
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#EqualityComparison">Equality comparison
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#NonEqualityComparison">Non-equality comparison
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#GreaterThanComparison">Greater-than comparison
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#GreaterOrEqualThanComparison">Greater-or-equal-than comparison
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#LessThanComparison">Less-than comparison
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#LessOrEqualThanComparison">Less-or-equal-than comparison
</a></li></ul></li><li class="liClosed"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#AppendixFloatingPointMathematicsCookbook">Appendix: Floating-point mathematics cookbook
</a><ul><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#ReducingComplicatedFunctionsIntoSimplerComponentsUsingComplexArithmetic">Reducing complicated functions into simpler components using complex arithmetic
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#ImplementingComplexNumberFunctions">Implementing complex-number functions
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#ImplementingRealNumberFunctions">Implementing real-number functions
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#FloatingPointAddition">Floating point addition
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#FloatingPointSubtraction">Floating point subtraction
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#FloatingPointMultiplication">Floating point multiplication
</a></li><li class="liBullet"><span class="bullet">&nbsp;</span><a href="https://bisqwit.iki.fi/story/howto/bitmath/#FloatingPointDivision">Floating point division
</a></li></ul></li></ul></div>
<h2><a name="AddAndSub"></a>ADD and SUB</h2><div class="deeper">
<h3><a name="AdditionWithoutCarry"></a>Addition without carry</h3><div class="deeper">
<h4><a name="UsingSubtraction"></a>Using subtraction</h4><div class="deeper">
Addition can be synthesized from subtraction by negating the source operand.
<p>Requirements:
</p><ul><li> Subtraction
</li><li> Negation
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type b      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span></pre>
</div><h4><a name="UsingBitwiseOperationsWithXor"></a>Using bitwise operations, with XOR</h4><div class="deeper">
Addition can be synthesized bit by bit using the logical XOR operation.
<p>Requirements:
</p><ul><li> Logical bit-wise XOR
</li><li> Binary bit-shift to left by 1
</li><li> Logical bit-test
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 mask   </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">mask </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    uint16 nextmask </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> mask </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// If A has that bit set?
	</span><span class="jSf6Z2BR2">    </span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">        </span><span class="jSfnT6pa2">// If result also has that bit set, set carry (next bit in result)
	</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">result </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">^=</span><span class="jSf6Z2BR2"> nextmask</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// This could also be |= instead of ^= .
	</span><span class="jSf6Z2BR2">        </span><span class="jSfnT6pa2">// Flip this bit in result
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">^=</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    </span><span class="jSf9DH-K2">}
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// If B has that bit set?
	</span><span class="jSf6Z2BR2">    </span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">        </span><span class="jSfnT6pa2">// If result also has that bit set, set carry (next bit in result)
	</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">result </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">^=</span><span class="jSf6Z2BR2"> nextmask</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// This could also be |= instead of ^= .
	</span><span class="jSf6Z2BR2">        </span><span class="jSfnT6pa2">// Flip this bit in result
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">^=</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    </span><span class="jSf9DH-K2">}
	</span><span class="jSf6Z2BR2">    mask </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> nextmask</span><span class="jSf9DH-K2">;
	}</span></pre>
The following version does potentially fewer iterations
by applying carry calculations to all bits simultaneously.
<p>Requirements:
</p><ul><li> Logical bit-wise XOR
</li><li> Logical bit-wise AND
</li><li> Binary bit-shift to left by 1
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type b      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        uint_type carry  </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">^</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">carry </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
</span><span class="jSf6Z2BR2">        </span><span class="jSf9DH-K2">{
</span><span class="jSf6Z2BR2">            </span><span class="jSfnT6pa2">// If you need the mathematical carry from addition,
</span><span class="jSf6Z2BR2">            </span><span class="jSfnT6pa2">// check the overflow from this shift.
</span><span class="jSf6Z2BR2">            uint_type shiftedcarry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> carry </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">            carry  </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> shiftedcarry</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">            result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">^</span><span class="jSf6Z2BR2"> shiftedcarry</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        </span><span class="jSf9DH-K2">}</span></pre>
</div><h4><a name="Other"></a>Other</h4><div class="deeper">
If you don't have the logical bit-wise XOR
operation, see the examples with ADC, below.
</div></div><h3><a name="AdcAdditionWithCarry"></a>ADC: Addition with carry</h3><div class="deeper">
<h4><a name="UsingAdditionComparison"></a>Using addition &amp; comparison</h4><div class="deeper">
For platforms without add-with-carry, carry can be synthesized
by comparing the result to the original.
<p>Requirements:
</p><ul><li> Addition without carry
</li><li> Unsigned less-than comparison
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type b      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2">      carry  </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> a</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// result &lt; b works too.</span></pre>
</div><h4><a name="UsingAdditionWithLargerOperands"></a>Using addition with larger operands</h4><div class="deeper">
Alternatively, you can get carry by calculating
with integer sizes larger than the source operands are.
<p>Requirements:
</p><ul><li> Addition without carry
</li><li> Logical bit shift right &amp; bit-and, or addressing individual byte components
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint32 temp   </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;

	</span><span class="jSfnT6pa2">// Alternative 1:
	</span><span class="jSf6Z2BR2">uint16 tempc</span><span class="jSf9DH-K2">[]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> temp</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">       </span><span class="jSfnT6pa2">// Treat temp as two 16-bit components
	</span><span class="jSf6Z2BR2">uint16 result  </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> tempc</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2">   </span><span class="jSfnT6pa2">// Take low word
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2">   carry   </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> tempc</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2">   </span><span class="jSfnT6pa2">// Take high word

	// Alternative 2: Bit-wise operations
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2">   carry  </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> temp </span><span class="jSfoF-_93">&gt;&gt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">16</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Bit-wise logical shift right
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> temp </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0xFFFF</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Bit-wise AND operation </span></pre>
</div><h4><a name="UsingBitwiseOperationsWithoutXor"></a>Using bitwise operations, without XOR</h4><div class="deeper">
Alternatively, if you don't have ADD or bit-wise XOR,
you can use bit-wise OR and some comparison logic instead.
This produces a carry flag, too.
<p>Requirements:
</p><ul><li> Logical bit-wise OR
</li><li> Binary bit-shift to left by 1
</li><li> Logical bit-test
</li><li> Logical bit-wise OR and AND (either as a test or calculation)
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 mask   </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">false</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">mask </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
</span><span class="jSf6Z2BR2">            </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> bit0 </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">            </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> bit1 </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;

</span><span class="jSf6Z2BR2">            </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">carry</span><span class="jSfoF-_93">)
</span><span class="jSf6Z2BR2">                </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">bit0 </span><span class="jSfoF-_93">==</span><span class="jSf6Z2BR2"> bit1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">|=</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> bit0 </span><span class="jSfoF-_93">|</span><span class="jSf6Z2BR2"> bit1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">            </span><span class="jSfWtbTI">else
</span><span class="jSf6Z2BR2">                </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">bit0 </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> bit1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">|=</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> bit0 </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> bit1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        
            mask </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> mask </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        </span><span class="jSf9DH-K2">}</span></pre>
</div><h4><a name="UsingBitwiseShiftWithCarryOrRotateWithCarryOperations"></a>Using bitwise shift-with-carry or rotate-with-carry operations</h4><div class="deeper">
If you don't have any OR or AND operations, but you do have
a shift-to-right-with-carry or a rotate-to-right-with-carry,
you can implement addition using those.
<p>Requirements:
</p><ul><li> Rotation-to-right with carry
</li><li> Either a logical right-shift that produces a carry, or a rotation-to-right that produces a carry
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> math_carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">false</span><span class="jSf9DH-K2">;

</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf5gZog2">int</span><span class="jSf6Z2BR2"> bit</span><span class="jSfdoBI62">=</span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> bit</span><span class="jSfoF-_93">&lt;</span><span class="jSfJnSXl1">16</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">++</span><span class="jSf6Z2BR2">bit</span><span class="jSfoF-_93">)
</span><span class="jSf6Z2BR2">        </span><span class="jSf9DH-K2">{
</span><span class="jSf6Z2BR2">            </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> bit0 </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a</span><span class="jSfoF-_93">&amp;</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Shift-to-right, get carry
</span><span class="jSf6Z2BR2">            </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> bit1 </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">&amp;</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b </span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Shift-to-right, get carry

</span><span class="jSf6Z2BR2">            </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">math_carry</span><span class="jSfoF-_93">)
</span><span class="jSf6Z2BR2">            </span><span class="jSf9DH-K2">{
</span><span class="jSf6Z2BR2">                </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> shift_carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> bit0 </span><span class="jSfoF-_93">==</span><span class="jSf6Z2BR2"> bit1</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">                </span><span class="jSfnT6pa2">// Shift-to-right with carry: sets msb=carry
</span><span class="jSf6Z2BR2">                result </span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">shift_carry</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">|=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0x80</span><span class="jSf9DH-K2">;

</span><span class="jSf6Z2BR2">                </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">bit0</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> math_carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">true</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">                </span><span class="jSfWtbTI">else</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">bit1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> math_carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">true</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">                </span><span class="jSfWtbTI">else</span><span class="jSf6Z2BR2"> math_carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">false</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">                </span><span class="jSfnT6pa2">// ^ Same as: math_carry = (bit0 || bit1);
</span><span class="jSf6Z2BR2">            </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">            </span><span class="jSfWtbTI">else
</span><span class="jSf6Z2BR2">            </span><span class="jSf9DH-K2">{
</span><span class="jSf6Z2BR2">                </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> shift_carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> bit0 </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> bit1</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">                </span><span class="jSfnT6pa2">// Shift-to-right with carry: sets msb=carry
</span><span class="jSf6Z2BR2">                result </span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">shift_carry</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">|=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0x80</span><span class="jSf9DH-K2">;

</span><span class="jSf6Z2BR2">                math_carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">false</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">                </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">bit0</span><span class="jSfoF-_93">)
</span><span class="jSf6Z2BR2">                    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">bit1</span><span class="jSfoF-_93">)
</span><span class="jSf6Z2BR2">                        math_carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">true</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">                </span><span class="jSfnT6pa2">// ^ Same as: math_carry = (bit0 &amp;&amp; bit1);
</span><span class="jSf6Z2BR2">            </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSf9DH-K2">}</span></pre>
Alternatively, as a state machine:
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> math_carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">false</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf5gZog2">int</span><span class="jSf6Z2BR2"> bit</span><span class="jSfdoBI62">=</span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> bit</span><span class="jSfoF-_93">&lt;</span><span class="jSfJnSXl1">16</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">++</span><span class="jSf6Z2BR2">bit</span><span class="jSfoF-_93">)
</span><span class="jSf6Z2BR2">            </span><span class="jSfWtbTI">switch</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">math_carry</span><span class="jSfoF-_93">)
</span><span class="jSf6Z2BR2">            </span><span class="jSf9DH-K2">{
</span><span class="jSf6Z2BR2">                </span><span class="jSfWtbTI">case</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">false</span><span class="jSfoF-_93">:
</span><span class="jSf6Z2BR2">                    </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> bit0 </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a</span><span class="jSfoF-_93">&amp;</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> a</span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Rotate-right A, get carry
</span><span class="jSf6Z2BR2">                      </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">bit0</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">goto</span><span class="jSf6Z2BR2"> sum1_x</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">                sum0_x</span><span class="jSfoF-_93">:
</span><span class="jSf6Z2BR2">                    </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> bit1 </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">&amp;</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Rotate-right B, get carry
</span><span class="jSf6Z2BR2">                      </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">bit1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">goto</span><span class="jSf6Z2BR2"> sum1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">                sum0</span><span class="jSfoF-_93">:
</span><span class="jSf6Z2BR2">                    result </span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Clear math_carry, rotate-right result
</span><span class="jSf6Z2BR2">                    math_carry</span><span class="jSfdoBI62">=</span><span class="jSfWtbTI">false</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">continue</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">                sum1_x</span><span class="jSfoF-_93">:
</span><span class="jSf6Z2BR2">                    </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> bit1 </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">&amp;</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Rotate-right B, get carry
</span><span class="jSf6Z2BR2">                      </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">bit1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">goto</span><span class="jSf6Z2BR2"> sum2</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">                sum1</span><span class="jSfoF-_93">:
</span><span class="jSf6Z2BR2">                    result </span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">|=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0x8000</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Set carry, rotate-right result
</span><span class="jSf6Z2BR2">                    math_carry</span><span class="jSfdoBI62">=</span><span class="jSfWtbTI">false</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">continue</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">                sum2</span><span class="jSfoF-_93">:
</span><span class="jSf6Z2BR2">                    result </span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Clear math_carry, rotate-right result
</span><span class="jSf6Z2BR2">                    math_carry</span><span class="jSfdoBI62">=</span><span class="jSfWtbTI">true</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">continue</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">                </span><span class="jSfWtbTI">case</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">true</span><span class="jSfoF-_93">:
</span><span class="jSf6Z2BR2">                    </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> bit0 </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a</span><span class="jSfoF-_93">&amp;</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> a</span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Rotate-right A, get carry
</span><span class="jSf6Z2BR2">                      </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">bit0</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">goto</span><span class="jSf6Z2BR2"> sum2_x</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">                    </span><span class="jSfWtbTI">goto</span><span class="jSf6Z2BR2"> sum1_x</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">                sum2_x</span><span class="jSfoF-_93">:
</span><span class="jSf6Z2BR2">                    </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> bit1 </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">&amp;</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Rotate-right B, get carry
</span><span class="jSf6Z2BR2">                      </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">bit1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">goto</span><span class="jSf6Z2BR2"> sum3</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">                    </span><span class="jSfWtbTI">goto</span><span class="jSf6Z2BR2"> sum2</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">                sum3</span><span class="jSfoF-_93">:
</span><span class="jSf6Z2BR2">                    result </span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">|=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0x8000</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Set carry, rotate-right result
</span><span class="jSf6Z2BR2">                    math_carry</span><span class="jSfdoBI62">=</span><span class="jSfWtbTI">true</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">continue</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">            </span><span class="jSf9DH-K2">}</span></pre>
Which would be equivalent to this 6502 code (8-bit operands),
assuming the 6502 didn't already have an addition operation:
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf5o7kl1">; Inputs: a_operand = operand 1
	;         b_operand = operand 2
	;	  C         = carry
	; Outputs:
	;         result    = operand 1 + operand 2 + carry
	;         C         = carry from addition
	;         A         = 8
	;         a_operand = 0
	;         b_operand = 0
	;         bits_remaining = 0
	</span><span class="jSf6Z2BR2">lda	#</span><span class="jSfpLmX01">8
	</span><span class="jSf6Z2BR2">sta	bits_remaining
	bcs	next_bit_carryset
	bcc	next_bit_carryclear
sum0_x:
	lsr	b_operand	</span><span class="jSf5o7kl1">; Sum=0. Get next LSB from B_operand
	; Arrived here when math_carry=0, A=0, B=x. (sum = 0 or 1)
	; Put B-bit (whatever it is) in result, and keep math_carry=false.
	</span><span class="jSf6Z2BR2">ror	result	</span><span class="jSf5o7kl1">; Rotate-right result
	;jmp	next_bit_carryclear	; Unconditional jump.
</span><span class="jSf6Z2BR2">next_bit_carryclear:
	dec	bits_remaining	</span><span class="jSf5o7kl1">; while(--bits_remaining &gt; 0)
	</span><span class="jSf6Z2BR2">beq	done_add_clc	</span><span class="jSf5o7kl1">; {
	;bne	carry_false
;carry_false:
	</span><span class="jSf6Z2BR2">lsr	a_operand	</span><span class="jSf5o7kl1">; Sum=0. Get next LSB from A_operand
	</span><span class="jSf6Z2BR2">bcc	sum0_x	        </span><span class="jSf5o7kl1">; Goto sum1_x if set, sum0_x if clear
</span><span class="jSf6Z2BR2">sum1_x:
	lsr	b_operand	</span><span class="jSf5o7kl1">; Sum=1. Get next LSB from B_operand
	</span><span class="jSf6Z2BR2">bcs	sum2a	        </span><span class="jSf5o7kl1">; Goto sum2a if set, sum1 if clear
	;bcc	sum1
;sum1:
	; Arrived here when math_carry=0, A=1, B=0 (sum=1)
	; Arrived here when math_carry=1, A=0, B=0 (sum=1)
	</span><span class="jSf6Z2BR2">sec		</span><span class="jSf5o7kl1">; Set carry
	</span><span class="jSf6Z2BR2">ror	result	</span><span class="jSf5o7kl1">; Rotate-right result
	</span><span class="jSf6Z2BR2">bne	next_bit_carryclear	</span><span class="jSf5o7kl1">; Unconditional jump.
</span><span class="jSf6Z2BR2">sum2a:
	</span><span class="jSf5o7kl1">; Arrived here when math_carry=0, A=1, B=1 (sum=2)
	; Arrived here when math_carry=1, A=0, B=1 (sum=2)
	</span><span class="jSf6Z2BR2">clc		</span><span class="jSf5o7kl1">; Clear carry
	</span><span class="jSf6Z2BR2">ror	result	</span><span class="jSf5o7kl1">; Rotate-right result
	</span><span class="jSf6Z2BR2">bpl	next_bit_carryset	</span><span class="jSf5o7kl1">; Unconditional jump.

</span><span class="jSf6Z2BR2">carry_true:
	lsr	a_operand	</span><span class="jSf5o7kl1">; Sum=1. Get next LSB from A_operand
	</span><span class="jSf6Z2BR2">bcc	sum1_x	        </span><span class="jSf5o7kl1">; Goto sum2_x if set, sum1_x if clear
	;bcs	sum2_x
;sum2_x:
	</span><span class="jSf6Z2BR2">lsr	b_operand	</span><span class="jSf5o7kl1">; Sum=2. Get next LSB from B_operand
	; Arrived here when math_carry=1, A=1, B=x. (sum= 2 or 3)
	; Put B-bit (whatever it is) in result, and keep math_carry=true.
	</span><span class="jSf6Z2BR2">ror	result	</span><span class="jSf5o7kl1">; Rotate-right result
	;jmp	next_bit_carryset	; Unconditional jump.
</span><span class="jSf6Z2BR2">next_bit_carryset:
	dec	bits_remaining	</span><span class="jSf5o7kl1">; if(!--bits_remaining)
	</span><span class="jSf6Z2BR2">bne	carry_true
	</span><span class="jSf5o7kl1">;beq	done_add_sec    ;
;done_add_sec:
	</span><span class="jSf6Z2BR2">sec
	bcs	done_add
done_add_clc:
	clc
	</span><span class="jSf5o7kl1">;bcc	done_add
</span><span class="jSf6Z2BR2">done_add:			</span><span class="jSf5o7kl1">; }</span></pre>
</div></div><h3><a name="AdditionOfLargerIntegersThanNativeRegisterSize"></a>Addition of larger integers than native register size</h3><div class="deeper">
When you need to add together integers that are larger
than your native register size, you need to utilize the carry.
<p>Requirements:
</p><ul><li> Addition with carry
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a</span><span class="jSf9DH-K2">[]</span><span class="jSf6Z2BR2">     </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">[];
	</span><span class="jSf6Z2BR2">uint_type b</span><span class="jSf9DH-K2">[]</span><span class="jSf6Z2BR2">     </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">[];
	</span><span class="jSf6Z2BR2">uint_type result</span><span class="jSf9DH-K2">[];
	
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">false</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Clear carry
	</span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">n </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> n </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">4</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">++</span><span class="jSf6Z2BR2">n</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// example if you're doing 32-bit addition using 8-bit integers
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    result</span><span class="jSf9DH-K2">[</span><span class="jSf6Z2BR2">n</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2">     </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a</span><span class="jSf9DH-K2">[</span><span class="jSf6Z2BR2">n</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">[</span><span class="jSf6Z2BR2">n</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> carry</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    carry         </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* save carry from this calculation*/</span><span class="jSf9DH-K2">;
	}</span></pre>
</div><h3><a name="SubtractionWithoutCarry"></a>Subtraction without carry</h3><div class="deeper">
<h4><a name="UsingAddition"></a>Using addition</h4><div class="deeper">
Subtraction can be synthesized from addition by negating the source operand.
<p>Requirements:
</p><ul><li> Addition
</li><li> Arithmetic negation
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type b      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span></pre>
</div></div><h3><a name="SbcSubtractionWithCarry"></a>SBC: Subtraction with carry</h3><div class="deeper">
For platforms without sub-with-carry, carry can be synthesized
by comparing the result to the original.
<p>Requirements:
</p><ul><li> Subtraction without carry
</li><li> Unsigned less-than comparison
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type b      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2">      carry  </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> result</span><span class="jSf9DH-K2">;</span></pre>
</div></div><h2><a name="SgnTestingIfValueIsNegative"></a>SGN / Testing if value is negative</h2><div class="deeper">
Testing if value is negative can be done with a comparison:
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">int_type a    </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> negative </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span></pre>
or by testing the sign bit:
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> negative </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0x8000</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// The highest-order bit of 16-bit integer</span></pre>
Testing the sign bit can also be done on some platforms
with a left-shift operation, if the operation produces a carry.
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Binary left-shift by 1
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> carry    </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* save carry from this calculation*/</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> negative </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> carry</span><span class="jSf9DH-K2">;</span></pre>
And some platforms, such as the 6502,
produce a is-negative flag simply by loading the value.
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">lda value </span><span class="jSf5o7kl1">; Load the highest-order byte of the value.
	; The N flag now contains the sign bit.
	</span><span class="jSf6Z2BR2">bmi got_negative </span><span class="jSf5o7kl1">;branch if N set
	</span><span class="jSf6Z2BR2">bpl got_positive </span><span class="jSf5o7kl1">;branch if N clear</span></pre>Similarly on i386:
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">mov eax, value   </span><span class="jSf5o7kl1">; Load the highest-order word of the value.
	</span><span class="jSf6Z2BR2">or eax, eax      </span><span class="jSf5o7kl1">; Test its bits
	; test eax, eax  ; Alternative way of testing the bits
	</span><span class="jSf6Z2BR2">js  got_negative </span><span class="jSf5o7kl1">; branch if SF set
	</span><span class="jSf6Z2BR2">jns got_positive </span><span class="jSf5o7kl1">; branch if SF clear</span></pre>
</div><h2><a name="Neg"></a>NEG</h2><div class="deeper">
<h3><a name="ArithmeticNegation"></a>Arithmetic negation</h3><div class="deeper">
Two's complement negation can be synthesized as follows:
<p>Requirements:
</p><ul><li> Logical negation (NOT operation / inversion)
</li><li> Unsigned addition of 1
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">~</span><span class="jSf6Z2BR2">a</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">       </span><span class="jSfnT6pa2">// NOT operation
	</span><span class="jSf6Z2BR2">result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span></pre>
Alternatively, you can implement it by subtracting from zero:
<p>Requirements:
</p><ul><li> Subtraction
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> a</span><span class="jSf9DH-K2">;</span></pre>
</div></div><h2><a name="Not"></a>NOT</h2><div class="deeper">
<h3><a name="LogicalNegationNotInvertOperation"></a>Logical negation (NOT / invert operation)</h3><div class="deeper">
Bit-wise NOT, i.e. logical negation, can be synthesized in various ways.
<h4><a name="UsingXor"></a>Using XOR</h4><div class="deeper">
XOR the operand with an integer where every bit is 1.
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">^</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0xFFFF</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// 0xFFFF has 16 bits</span></pre>
</div><h4><a name="UsingSubtraction_2"></a>Using subtraction</h4><div class="deeper">
Subtract the operand from an integer where every bit is 1.
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0xFFFF</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> a</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// 0xFFFF has 16 bits</span></pre>
</div><h4><a name="UsingArithmeticNegation"></a>Using arithmetic negation</h4><div class="deeper">
Negate the operand and subtract one. (Depends on two's complement arithmetic.)
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">a</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span></pre>
</div></div></div><h2><a name="AndAndOr"></a>AND and OR</h2><div class="deeper">
<h3><a name="LogicalBitWiseAnd"></a>Logical bit-wise AND</h3><div class="deeper">
Bit-wise AND, i.e. logical conjunction, can be synthesized in various ways.
<h4><a name="UsingNotAndOr"></a>Using NOT and OR</h4><div class="deeper">
a &amp; b = ~(~a | ~b)
<p>Requirements:
</p><ul><li> Logical negation (NOT operation / inversion)
</li><li> Logical disjunction (OR operation)
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type b      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">~</span><span class="jSf6Z2BR2">a</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Logical NOT
	</span><span class="jSf6Z2BR2">b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">~</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Logical NOT
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">|</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Logical OR
	</span><span class="jSf6Z2BR2">result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">~</span><span class="jSf6Z2BR2">result</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Invert result</span></pre>
</div><h4><a name="DoingItBitByBit"></a>Doing it bit-by-bit</h4><div class="deeper">
If you have an operation that tests whether a particular
bit is set, you can implement AND using a loop.
<p>Requirements:
</p><ul><li> Logical bit-test
</li><li> Logical bit-set
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">n </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> n </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">16</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">++</span><span class="jSf6Z2BR2">n</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Test whether the bit is set in both operands
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> n</span><span class="jSfoF-_93">))</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test whether bit n is set in a
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> n</span><span class="jSfoF-_93">))</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test whether bit n is set in b
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">|=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> n</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Set bit N in target value
	</span><span class="jSf9DH-K2">}</span></pre>
Alternative:
<p></p><ul><li> Logical bit-test
</li><li> Binary bit-shift to left by 1
</li><li> Addition
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">uint16 mask </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> mask </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> mask </span><span class="jSfoF-_93">&lt;&lt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Test whether the bit is set in both operands
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test A and mask have common bits
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test B and mask have common bits
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;
	}</span></pre>
</div><h4><a name="BitByBitUsingArithmeticOperationsOnly"></a>Bit-by-bit using arithmetic operations only</h4><div class="deeper">
<ul><li> Unsigned integer division (by 2), round towards zero
</li><li> Unsigned integer modulo (by 2) (division remainder)
</li><li> Integer addition
</li><li> Integer equality comparison against zero
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 mask   </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf5gZog2">int</span><span class="jSf6Z2BR2"> bit</span><span class="jSfdoBI62">=</span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> bit</span><span class="jSfoF-_93">&lt;</span><span class="jSfJnSXl1">16</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">++</span><span class="jSf6Z2BR2">bit</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">((</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">%</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&amp;&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">%</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">/</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Integer division, round towards zero
	</span><span class="jSf6Z2BR2">    b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b </span><span class="jSfoF-_93">/</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Integer division, round towards zero
	</span><span class="jSf6Z2BR2">    mask </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> mask </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Multiply mask by 2
	</span><span class="jSf9DH-K2">}</span></pre>
</div></div><h3><a name="LogicalBitWiseOr"></a>Logical bit-wise OR</h3><div class="deeper">
Bit-wise OR, i.e. logical conjunction, can be synthesized in various ways.
<h4><a name="UsingNotAndAnd"></a>Using NOT and AND</h4><div class="deeper">
a | b = ~(~a &amp; ~b)
<p>Requirements:
</p><ul><li> Logical negation (NOT operation / inversion)
</li><li> Logical conjunction (AND operation)
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type b      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">~</span><span class="jSf6Z2BR2">a</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Logical NOT
	</span><span class="jSf6Z2BR2">b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">~</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Logical NOT
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Logical AND
	</span><span class="jSf6Z2BR2">result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">~</span><span class="jSf6Z2BR2">result</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Invert result</span></pre>
</div><h4><a name="DoingItBitByBit_2"></a>Doing it bit-by-bit</h4><div class="deeper">
If you have an operation that tests whether a particular
bit is set, you can implement OR using a loop.
<p>Requirements:
</p><ul><li> Logical bit-test
</li><li> Logical bit-set
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">n </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> n </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">16</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">++</span><span class="jSf6Z2BR2">n</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Test whether the bit is set in either operand
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> n</span><span class="jSfoF-_93">))</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test whether bit n is set in a
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">|=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> n</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Set bit N in target value
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> n</span><span class="jSfoF-_93">))</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test whether bit n is set in b
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">|=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> n</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Set bit N in target value
	</span><span class="jSf9DH-K2">}</span></pre>
Alternative:
<p></p><ul><li> Logical bit-test
</li><li> Binary bit-shift to left by 1
</li><li> Subtraction
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0xFFFF</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">uint16 mask </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> mask </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> mask </span><span class="jSfoF-_93">&lt;&lt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Deduct bit, if it's CLEAR in both operands
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(!(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSfoF-_93">))</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test A and mask don't have common bits
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(!(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSfoF-_93">))</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test B and mask don't have common bits
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;
	}</span></pre>
</div><h4><a name="BitByBitUsingArithmeticOperationsOnly_2"></a>Bit-by-bit using arithmetic operations only</h4><div class="deeper">
<ul><li> Unsigned integer division (by 2), round towards zero
</li><li> Unsigned integer modulo (by 2) (division remainder)
</li><li> Integer addition
</li><li> Integer equality comparison against zero
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 mask   </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf5gZog2">int</span><span class="jSf6Z2BR2"> bit</span><span class="jSfdoBI62">=</span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> bit</span><span class="jSfoF-_93">&lt;</span><span class="jSfJnSXl1">16</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">++</span><span class="jSf6Z2BR2">bit</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">((</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">%</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">||</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">%</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">/</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Integer division, round towards zero
	</span><span class="jSf6Z2BR2">    b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b </span><span class="jSfoF-_93">/</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Integer division, round towards zero
	</span><span class="jSf6Z2BR2">    mask </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> mask </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Multiply mask by 2
	</span><span class="jSf9DH-K2">}</span></pre>
</div></div></div><h2><a name="Xor"></a>XOR</h2><div class="deeper">
<h3><a name="LogicalBitWiseXor"></a>Logical bit-wise XOR</h3><div class="deeper">
Bit-wise XOR, i.e. logical bit-wise exclusive-OR, can be synthesized in various ways.
<h4><a name="UsingNotOrAndAnd"></a>Using NOT, OR and AND</h4><div class="deeper">
a ^ b = (a &amp; ~b) | (b &amp; ~a)<br>
Two unary operations, three binary operations. Max sequence depth: 3
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type nota </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">~</span><span class="jSf6Z2BR2">a</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Logical NOT
	</span><span class="jSf6Z2BR2">uint_type notb </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">~</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Logical NOT
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> notb</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">|</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> nota</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;</span></pre>
a ^ b = (a | b) &amp;~ (a &amp; b)<br>
One unary operation, three binary operations. Max sequence depth: 3
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">|</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">~(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;</span></pre>
</div><h4><a name="DoingItBitByBit_3"></a>Doing it bit-by-bit</h4><div class="deeper">
You can test bit by bit whether the bit is different in both operands.
<p>Requirements:
</p><ul><li> Logical bit-test
</li><li> Logical bit-set
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">n </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> n </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">16</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">++</span><span class="jSf6Z2BR2">n</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Test whether the bit is set in a but not b
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> n</span><span class="jSfoF-_93">))</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Test whether bit n is set in a
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(!(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> n</span><span class="jSfoF-_93">)))</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test whether bit n is not set in b
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">|=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> n</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Set bit N in target value

	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Test whether the bit is set in b but not a
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> n</span><span class="jSfoF-_93">))</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Test whether bit n is set in b
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(!(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> n</span><span class="jSfoF-_93">)))</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test whether bit n is not set in a
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">|=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> n</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Set bit N in target value
	</span><span class="jSf9DH-K2">}</span></pre>
Alternative:
<p></p><ul><li> Logical bit-test
</li><li> Binary bit-shift to left by 1
</li><li> Subtraction
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0xFFFF</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">uint16 mask </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> mask </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> mask </span><span class="jSfoF-_93">&lt;&lt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Deduct bit, if it's CLEAR in both operands
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(!(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSfoF-_93">))</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test A and mask don't have common bits
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(!(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSfoF-_93">))</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test B and mask don't have common bits
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;

	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Deduct bit, if it's SET in both operands
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test A and mask have common bits
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Test B and mask have common bits
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;
	}</span></pre>
</div><h4><a name="BitByBitUsingArithmeticOperationsOnly_3"></a>Bit-by-bit using arithmetic operations only</h4><div class="deeper">
<ul><li> Unsigned integer division (by 2), round towards zero
</li><li> Unsigned integer modulo (by 2) (division remainder)
</li><li> Integer addition
</li><li> Integer equality comparison
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 mask   </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf5gZog2">int</span><span class="jSf6Z2BR2"> bit</span><span class="jSfdoBI62">=</span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> bit</span><span class="jSfoF-_93">&lt;</span><span class="jSfJnSXl1">16</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">++</span><span class="jSf6Z2BR2">bit</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(((</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">%</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">%</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSfoF-_93">))</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">==</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">/</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Integer division, round towards zero
	</span><span class="jSf6Z2BR2">    b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b </span><span class="jSfoF-_93">/</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Integer division, round towards zero
	</span><span class="jSf6Z2BR2">    mask </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> mask </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Multiply mask by 2
	</span><span class="jSf9DH-K2">}</span></pre>
</div></div></div><h2><a name="ShlLslAslSlLogicalBinaryArithmeticBitShiftToLeftBy 1"></a>SHL/LSL/ASL/SL: Logical/binary/arithmetic bit-shift to left by 1</h2><div class="deeper">
Logical bit-shifting to the left can be accomplished by multiplying the value by 2, i.e. adding the value to itself.
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> a</span><span class="jSf9DH-K2">;
	</span><span class="jSfnT6pa2">// This result may also produce a carry. It's often needed.</span></pre>
<h3><a name="LargerSizeBitShiftingToLeft"></a>Larger-size bit-shifting to left</h3><div class="deeper">
<pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint8 a</span><span class="jSf9DH-K2">[]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">[];
	
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">false</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Clear carry
	</span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">n </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> n </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">4</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">++</span><span class="jSf6Z2BR2">n</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// example if you're doing 32-bit shift using 8-bit integers
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> new_carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a</span><span class="jSf9DH-K2">[</span><span class="jSf6Z2BR2">n</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0x80</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">?</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">:</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Check the highest-order bit
	</span><span class="jSf6Z2BR2">    result</span><span class="jSf9DH-K2">[</span><span class="jSf6Z2BR2">n</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a</span><span class="jSf9DH-K2">[</span><span class="jSf6Z2BR2">n</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">|</span><span class="jSf6Z2BR2"> carry</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    carry     </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> new_carry</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* save carry from this calculation*/
	</span><span class="jSf9DH-K2">}</span></pre>
</div></div><h2><a name="ShrLsrSrLogicalBinaryBitShiftToRightBy 1"></a>SHR/LSR/SR: Logical/binary bit-shift to right by 1</h2><div class="deeper">
Logical bit-shifting to the right can be accomplished by dividing
the value by 2, assuming division always rounds towards zero.
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">/</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">;</span></pre>
Of course, often that operation is not available, so...
<h3><a name="WithoutDivisions"></a>Without divisions</h3><div class="deeper">
Logical bit-shifting to the right can also be accomplished
through logical bit-shifting to the LEFT by inverse the amount.
This requires the use of a register that is double the original's size.
<p>Requirements:
</p><ul><li> Logical bit shift LEFT
</li><li> Addressing individual byte components
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a        </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type amount  </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> shift_amount</span><span class="jSf9DH-K2">;

	</span><span class="jSf6Z2BR2">amount </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">16</span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">amount</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Invert the shift amount

	</span><span class="jSf6Z2BR2">uint32 temp </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> amount</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Shift LEFT

	</span><span class="jSf6Z2BR2">uint16 tempc</span><span class="jSf9DH-K2">[]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> temp</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">       </span><span class="jSfnT6pa2">// Treat temp as two 16-bit components
	</span><span class="jSf6Z2BR2">uint16 result  </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> tempc</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2">   </span><span class="jSfnT6pa2">// Take high word</span></pre>
</div><h3><a name="LargerSizeBitShiftingToRight"></a>Larger-size bit-shifting to right</h3><div class="deeper">
<pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint8 a</span><span class="jSf9DH-K2">[]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">[];
	
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">false</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Clear carry
	</span><span class="jSfWtbTI">for</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">n </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> n </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">4</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">++</span><span class="jSf6Z2BR2">n</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// example if you're doing 32-bit shift using 8-bit integers
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> new_carry </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a</span><span class="jSf9DH-K2">[</span><span class="jSf6Z2BR2">n</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Check the lowest-order bit
	</span><span class="jSf6Z2BR2">    result</span><span class="jSf9DH-K2">[</span><span class="jSf6Z2BR2">n</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a</span><span class="jSf9DH-K2">[</span><span class="jSf6Z2BR2">n</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&gt;&gt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">|</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">carry </span><span class="jSfoF-_93">?</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0x80</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">:</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0x00</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    carry     </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> new_carry</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* save carry from this calculation*/
	</span><span class="jSf9DH-K2">}</span></pre>
</div><h3><a name="WhenYouHaveArithmeticBitShiftToTheRight"></a>When you have arithmetic bit-shift to the right</h3><div class="deeper">
If you have an arithmetic bit-shifting operator but not a logical one,
you can synthesize the logical one by clearing the top-order bits.
<p>Requirements:
</p><ul><li> Arithmetic bit-shift to right
</li><li> Logical AND operation
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">&gt;&gt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0x7FFF</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">  </span><span class="jSfnT6pa2">// Keep all bits except the topmost one.</span></pre>
Generalized to shifting by any amount:
<p>Requirements:
</p><ul><li> Logical bit-shift to right
</li><li> Logical bit-shift to left
</li><li> Logical AND operation
</li><li> Subtract by 1
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a       </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type amount </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> shift_amount</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result  </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">&gt;&gt;</span><span class="jSf6Z2BR2"> amount</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 mask    </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">1</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">16</span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">amount</span><span class="jSfoF-_93">))</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Change 16 to the bit-width of result
	</span><span class="jSf6Z2BR2">result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> mask</span><span class="jSf9DH-K2">;</span></pre>
</div><h3><a name="WhenYouDoNotHaveAnyBitOperations"></a>When you do not have any bit-operations</h3><div class="deeper">
If you do not have bit-shifts or bit-tests,
the following algorithm can still be used to
shift <em>one</em> bit to the right, i.e. divide by two:
<p>Requirements:
</p><ul><li> Addition and subtraction
</li><li> Unsigned greater-than comparison
</li></ul><p>Note that you must know the upper limit of your input beforehand.
E.g. if your values are in range 0–99, you will need
six comparisons (2,4,8,16,32,64), but you do not
need 128 or higher. Comparing against 1 is also unnecessary.
</p><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSfnT6pa2">// Repeat these lines for powers of two, according
	// to the upper limit of known value of A.
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSfJnSXl1">64</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">32</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">64</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSfJnSXl1">32</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">16</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">32</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSfJnSXl1">16</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">8</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">16</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">8</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">4</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">8</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">4</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">4</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}</span></pre>
</div></div><h2><a name="AsrSraArithmeticBitShiftToTheRight"></a>ASR/SRA: Arithmetic bit-shift to the right</h2><div class="deeper">
Whereas logical bit-shiting to the right clears the most significant bits,
i.e. it shifts in zeroes, <em>arithmetic</em> bit-shifting to the right will
make copies of the most significant bit.
<p>Examples:
</p><ul><li> 00101111 &gt;&gt; 1 = 00010111
</li><li> 00101111 &gt;&gt; 3 = 00000101
</li><li> 10101111 &gt;&gt; 1 = 11010111
</li><li> 10101111 &gt;&gt; 3 = 11110101
</li></ul><h3><a name="WhenShiftingBy 1Bit"></a>When shifting by 1 bit</h3><div class="deeper">
<h4><a name="WhenShiftingUsesCarry"></a>When shifting uses carry</h4><div class="deeper">
When your platform's right-shift operation shifts in the carry flag
instead of a zero-bit, you can use this to your advantage.
<p>Example on 6502
</p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">cmp #</span><span class="jSfpLmX01">0	</span><span class="jSf5o7kl1">; Compare value to zero. Sets carry if it's negative.
	</span><span class="jSf6Z2BR2">ror a   </span><span class="jSf5o7kl1">; Shift to the right.
	</span><span class="jSf6Z2BR2">        </span><span class="jSf5o7kl1">; Carry becomes the new highest bit,
	</span><span class="jSf6Z2BR2">        </span><span class="jSf5o7kl1">; lowest bit becomes the new carry.</span></pre>
</div><h4><a name="UsingBitTest"></a>Using bit-test</h4><div class="deeper">
Requirements:
<p></p><ul><li> Binary bit-shift to right by 1
</li><li> Logical bit-test
</li><li> Logical bit-set
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">&gt;&gt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Logical bit-shift to the right
	// Copy the sign bit from the original.
	</span><span class="jSf6Z2BR2">result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">|</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0x8000</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;
	</span><span class="jSfnT6pa2">// ^ This can also be done with a bit-test &amp; bit-set operation
	//   if it is cheaper, or if OR and AND operations are not available.</span></pre>
</div></div><h3><a name="WhenShiftingByNBits"></a>When shifting by N bits</h3><div class="deeper">
<pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint16 a         </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type amount </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> shift_amount</span><span class="jSf9DH-K2">;

	</span><span class="jSf6Z2BR2">uint16 result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">&gt;&gt;</span><span class="jSf6Z2BR2"> amount</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0x8000</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// If the number was signed
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// This shift depends on leftshiting discarding
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// the excess bits:
	</span><span class="jSf6Z2BR2">    uint16 signbits </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0xFFFF</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">&lt;&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">16</span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">amount</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;

	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Alternative way:
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">//uint16 signbits = ~((1 &lt;&lt; (16-amount)) - 1);

	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Patch in the sign bits:
	</span><span class="jSf6Z2BR2">    result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">|</span><span class="jSf6Z2BR2"> signbits</span><span class="jSf9DH-K2">;
	}</span></pre>
</div></div><h2><a name="MulUnsignedMultiplication"></a>MUL: Unsigned multiplication</h2><div class="deeper">
<h3><a name="MultiplicationWithoutMultiplicationOperations"></a>Multiplication without multiplication operations</h3><div class="deeper">
Unsigned multiplication can be performed with additions and logical bit-shifts.
<p>Requirements:
</p><ul><li> Binary bit-shift to right by 1 (Note: This must be LOGICAL, not arithmetic shift.)
</li><li> Least significant bit test
</li><li> Addition
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type b      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// If the lowest order bit is set in A?
	</span><span class="jSf6Z2BR2">    </span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    </span><span class="jSf9DH-K2">}
	</span><span class="jSf6Z2BR2">    a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">&gt;&gt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Note: This must set highest order bit ZERO. It must not copy the sign bit.
	</span><span class="jSf6Z2BR2">    b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">  </span><span class="jSfnT6pa2">// Alternatively, left-shift by 1 bit
	</span><span class="jSf9DH-K2">}</span></pre>
If you need to do multiplication with larger integer sizes,
just implement this algorithm using additions and shifts
for larger integer sizes.
</div><h3><a name="MultiplicationWithoutAnyBitOperations"></a>Multiplication without any bit-operations</h3><div class="deeper">
If you do not have bit-shifts or bit-tests, the following algorithm can still be used:
<p>Requirements:
</p><ul><li> Addition and subtraction
</li><li> Unsigned greater-than comparison
</li><li> Random access memory or a stack
</li></ul><p>Note that you must know the upper limit of one of the parameters beforehand.
E.g. if your values are in range 0–99, you will need a stack of seven slots
and seven comparisons (1,2,4,8,16,32,64), but you do not need 128 or higher.
</p><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        uint_type stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">7</span><span class="jSf9DH-K2">];
</span><span class="jSf6Z2BR2">        stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// b*1
</span><span class="jSf6Z2BR2">        stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// b*2
</span><span class="jSf6Z2BR2">        stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// b*4
</span><span class="jSf6Z2BR2">        stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">3</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// b*8
</span><span class="jSf6Z2BR2">        stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">4</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// b*16
</span><span class="jSf6Z2BR2">        stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">5</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// b*32
</span><span class="jSf6Z2BR2">        stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">6</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">          </span><span class="jSfnT6pa2">// b*64
	</span><span class="jSf6Z2BR2">uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSfnT6pa2">// Repeat these lines for powers of two, according
	// to the upper limit of known value of A.
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSfJnSXl1">64</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">6</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">64</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">else</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* ignore stack[6] */</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSfJnSXl1">32</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">5</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">32</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">else</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* ignore stack[5] */</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSfJnSXl1">16</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">4</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">16</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">else</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* ignore stack[4] */</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">8</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">3</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">8</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">else</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* ignore stack[3] */</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">4</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">4</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">else</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* ignore stack[2] */</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">else</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* ignore stack[1] */</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2">             </span><span class="jSf9DH-K2">}</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">else</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* ignore stack[0] */</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}</span></pre>
This algorithm is faster than a raw addition-loop for all but the smallest multipliers.
<p>If no extra memory or a stack is available, then an addition loop is the only option.
</p><p>Requirements:
</p><ul><li> Addition and subtraction
</li><li> Is-zero comparison
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;

</span><span class="jSf6Z2BR2">        </span><span class="jSfnT6pa2">/* Optional: Ensure minimal number of loops by swapping operands if necessary */
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> uint_type temp </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> temp</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}

</span><span class="jSf6Z2BR2">        uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
</span><span class="jSf6Z2BR2">        </span><span class="jSf9DH-K2">{
</span><span class="jSf6Z2BR2">            result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">            a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        </span><span class="jSf9DH-K2">}</span></pre>
</div><h3><a name="MultiplicationOfLargerIntegers"></a>Multiplication of larger integers</h3><div class="deeper">
You can construct larger-size multiplications by hand-crafting the multiplication
using bitshifts and additions for larger integer sizes. Alternatively, you can
use actual multiplications in the same way as you would do it on paper:
<p></p><pre>      15              wx        EA=x*z   GF=w*z
     *74             *yz        JH=x*y   LK=w*y
    ----            ----
   =  20           =  EA        B = E+F+H
   +  4            + GF         C = G+J   + carry from B
   + 35            + JH         D = L     + carry from C
   + 7             +LK
    ----            ----
    1110            DCBA
</pre>Example in x86_64 assembler, producing
128-bit * 128-bit = 256-bit multiplication with 64-bit registers:
<p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">mov rsi, </span><span class="jSfpLmX01">0 </span><span class="jSf6Z2BR2"> </span><span class="jSf5o7kl1">; use a zero as a constant sometimes.
	; DCBA now contains ????.
	; store 00EA:
	</span><span class="jSf6Z2BR2">mov rax, x  </span><span class="jSf5o7kl1">; low 64 bits of operand 1
	</span><span class="jSf6Z2BR2">mul      z  </span><span class="jSf5o7kl1">; low 64 bits of operand 2
	</span><span class="jSf6Z2BR2">mov A, rax  </span><span class="jSf5o7kl1">; store low 64 bits of result (A)
	</span><span class="jSf6Z2BR2">mov rbx, rdx  </span><span class="jSf5o7kl1">; store high 64 bits of result (E)
	</span><span class="jSf6Z2BR2">mov rcx, rsi  </span><span class="jSf5o7kl1">; clear C and D
	</span><span class="jSf6Z2BR2">mov rdi, rsi
	</span><span class="jSf5o7kl1">; add 0GF0:
	</span><span class="jSf6Z2BR2">mov rax, x  </span><span class="jSf5o7kl1">; low 64 bits of operand 1
	</span><span class="jSf6Z2BR2">mul      y  </span><span class="jSf5o7kl1">; high 64 bits of operand 2
	</span><span class="jSf6Z2BR2">add rbx, rax  </span><span class="jSf5o7kl1">; store low 64 bits of result (F)
	</span><span class="jSf6Z2BR2">adc rcx, rdx  </span><span class="jSf5o7kl1">; store high 64 bits of result (G)
	;adc rdi, rsi ; not needed here, EA+GF0 never overflows to fourth digit
	; add 0JH0:
	</span><span class="jSf6Z2BR2">mov rax, w  </span><span class="jSf5o7kl1">; high 64 bits of operand 1
	</span><span class="jSf6Z2BR2">mul      z  </span><span class="jSf5o7kl1">; low 64 bits of operand 2
	</span><span class="jSf6Z2BR2">add rbx, rax  </span><span class="jSf5o7kl1">; store low 64 bits of result (H)
	</span><span class="jSf6Z2BR2">adc rcx, rdx  </span><span class="jSf5o7kl1">; store high 64 bits of result (J)
	</span><span class="jSf6Z2BR2">adc rdi, rsi
	</span><span class="jSf5o7kl1">; add LK00:
	</span><span class="jSf6Z2BR2">mov rax, w  </span><span class="jSf5o7kl1">; high 64 bits of operand 1
	</span><span class="jSf6Z2BR2">mul      y  </span><span class="jSf5o7kl1">; high 64 bits of operand 2
	</span><span class="jSf6Z2BR2">add rcx, rax  </span><span class="jSf5o7kl1">; store low 64 bits of result (K)
	</span><span class="jSf6Z2BR2">adc rdi, rdx  </span><span class="jSf5o7kl1">; store high 64 bits of result (L)
	; store to actual DCB
	</span><span class="jSf6Z2BR2">mov B, rbx
	mov C, rcx
	mov D, rdi</span></pre>
See also:
<ul><li> <a class="extlink" id="i852E6FE1" href="http://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba algorithm</a>
</li><li> <a class="extlink" id="iD8BD3178" href="http://en.wikipedia.org/wiki/Toom%E2%80%93Cook_multiplication">Toom-cook algorithm</a>
</li><li> <a class="extlink" id="i3AB5630E" href="http://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm">Schönhage–Strassen algorithm</a>
</li><li> <a class="extlink" id="iE6E6F0C5" href="http://en.wikipedia.org/wiki/F%C3%BCrer%27s_algorithm">Fürer's algorithm</a>
</li></ul></div></div><h2><a name="MliImulMuliSignedMultiplication"></a>MLI/IMUL/MULI: Signed multiplication</h2><div class="deeper">
The unsigned multiplication works for signed multiplication too,
if the target value is of the same bit-width as the source-values
and two’s complement is used. No special attention is needed for the sign bits.
<p>If these conditions are not met, then signed multiplication can be accomplished
by doing an unsigned multiplication and taking manually care of the negative-signs.
</p><p>Requirements:
</p><ul><li> Unsigned multiplication
</li><li> Testing if value is negative
</li><li> Arithmetic negation
</li><li> Logical inversion
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">int_type    a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type    b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> sign </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">false</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    sign </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">!</span><span class="jSf6Z2BR2">sign</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Toggle the signed flag
	</span><span class="jSf6Z2BR2">    a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">a</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Negate a
	</span><span class="jSf9DH-K2">}
	</span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    sign </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">!</span><span class="jSf6Z2BR2">sign</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Toggle the signed flag
	</span><span class="jSf6Z2BR2">    b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Negate b
	</span><span class="jSf9DH-K2">}
	</span><span class="jSfnT6pa2">// a and b are both positive now
	</span><span class="jSf6Z2BR2">int_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Do unsigned multiplication
	</span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">sign</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Negate the result
	</span><span class="jSf6Z2BR2">    result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">result</span><span class="jSf9DH-K2">;
	}</span></pre>
</div><h2><a name="DivAndModDivisionAndModulo"></a>DIV and MOD: Division and modulo</h2><div class="deeper">
Unsigned integer division and modulo can be performed with additions, subtractions and logical bit-shifts.
<p>Requirements:
</p><ul><li> Binary bit-shift to right by 1 (Note: This must be LOGICAL, not arithmetic shift.)
</li><li> Addition
</li><li> Subtraction
</li><li> Unsigned greater-or-equal-than comparison
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">divisor </span><span class="jSfoF-_93">==</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// TODO: Do whatever should happen when dividing by zero.
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">//       Don't run the rest of this algorithm if divisor = 0.
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">return</span><span class="jSf9DH-K2">;
	}
</span><span class="jSf6Z2BR2">        
	uint_type scaled_divisor </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> divisor</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">  </span><span class="jSfnT6pa2">// The right-hand side of division
	</span><span class="jSf6Z2BR2">uint_type remain         </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> dividend</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// The left-hand side of division, i.e. what is being divided
	</span><span class="jSf6Z2BR2">uint_type result   </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type multiple </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        
	</span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">scaled_divisor </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> dividend</span><span class="jSfoF-_93">)
	</span><span class="jSfnT6pa2">// Alternative: while(!(scaled_divisor &amp; 0x8000)) // For 16-bit, test highest order bit.
	// Alternative: while(not_signed(scaled_divisor)) // Same as above.
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    scaled_divisor </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> scaled_divisor </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> scaled_divisor</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Multiply by two.
	</span><span class="jSf6Z2BR2">    multiple       </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> multiple       </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> multiple</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">       </span><span class="jSfnT6pa2">// Multiply by two.
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// You can also use binary shift-by-left here (i.e. multiple = multiple &lt;&lt; 1).
	</span><span class="jSf9DH-K2">}
	</span><span class="jSfWtbTI">do</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">remain </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> scaled_divisor</span><span class="jSfoF-_93">)
	</span><span class="jSf6Z2BR2">    </span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">        remain </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> remain </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> scaled_divisor</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> multiple</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    </span><span class="jSf9DH-K2">}
	</span><span class="jSf6Z2BR2">    scaled_divisor </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> scaled_divisor </span><span class="jSfoF-_93">&gt;&gt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Divide by two.
	</span><span class="jSf6Z2BR2">    multiple       </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> multiple       </span><span class="jSfoF-_93">&gt;&gt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	}</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">multiple </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;
	
	</span><span class="jSfnT6pa2">// Now: result = division result (quotient)
	//      remain = division remainder (modulo)</span></pre>
If you need to do division or modulo with larger integer
sizes, just implement this algorithm using additions and
shifts for larger integer sizes.
<h4><a name="Explanation"></a>Explanation</h4><div class="deeper">
To understand how the division algorithm works,
consider this simple algorithm:
<p>Requirements:
</p><ul><li> Addition
</li><li> Subtraction
</li><li> Unsigned greater-or-equal-than comparison
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type remain  </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> dividend</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// The left-hand side of division, i.e. what is being divided
	</span><span class="jSf6Z2BR2">uint_type result  </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">remain </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> divisor</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    remain </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> remain </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> divisor</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	}</span></pre>
This is how you might do divisions, if you had no bit-shift operations available.
You simply <em>measure</em> how many times the divisor can be subtracted from the dividend
before it becomes negative.
<p>However, suppose your dividend is 1500 and your divisor is 2.
This algorithm will loop for 750 iterations.
How to improve it? Well, you could first divide by sixteen, i.e. two times <em>eight</em>.
</p><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type remain  </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> dividend</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type result  </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">remain </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> divisor</span><span class="jSfoF-_93">*</span><span class="jSfJnSXl1">8</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    remain </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> remain </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> divisor</span><span class="jSfoF-_93">*</span><span class="jSfJnSXl1">8</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">8</span><span class="jSf9DH-K2">;
	}
	</span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">remain </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> divisor</span><span class="jSfoF-_93">*</span><span class="jSfJnSXl1">1</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    remain </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> remain </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> divisor</span><span class="jSfoF-_93">*</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	}</span></pre>
Now this algorithm will loop for 99 iterations, and produces the same correct result.
But we could do better! How about dividing first by <em>128</em>?
And maybe we could subdivide that 16 into 4 and 8.
<p>The first algorithm automates this subdivision process,
doing the compare-and-subtract test for all power-of-two multiples
of the divisor, converging towards the O(log2(n)<em></em>) goal.
It begins with the largest multiple of the divisor
that is not larger than the dividend.
</p></div><h4><a name="ImplementingWithAStackWithoutBitShiftOperations"></a>Implementing with a stack, without bit-shift operations</h4><div class="deeper">
<pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type remain         </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> dividend</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// The left-hand side of division, i.e. what is being divided
	</span><span class="jSf6Z2BR2">uint_type scaled_divisor </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> divisor</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">  </span><span class="jSfnT6pa2">// The right-hand side of division
	</span><span class="jSf6Z2BR2">uint_type result   </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type multiple </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	</span><span class="jSfnT6pa2">// TODO: Check for zero divisor

	</span><span class="jSf6Z2BR2">stack_push</span><span class="jSfoF-_93">(</span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">scaled_divisor </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> dividend</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    stack_push</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">multiple</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    stack_push</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">scaled_divisor</span><span class="jSfoF-_93">)</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    scaled_divisor </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> scaled_divisor </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> scaled_divisor</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Multiply by two.
	</span><span class="jSf6Z2BR2">    multiple       </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> multiple       </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> multiple</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">       </span><span class="jSfnT6pa2">// Multiply by two.
	</span><span class="jSf9DH-K2">}
	</span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">scaled_divisor </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> stack_pop</span><span class="jSfoF-_93">())</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">!=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    multiple </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> stack_pop</span><span class="jSfoF-_93">()</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">remain </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> scaled_divisor</span><span class="jSfoF-_93">)
	</span><span class="jSf6Z2BR2">    </span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">        remain </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> remain </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> scaled_divisor</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> multiple</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    </span><span class="jSf9DH-K2">}
	}
	</span><span class="jSfnT6pa2">// Now: result = division result (quotient)
	//      remain = division remainder (modulo)</span></pre>
</div><h3><a name="DviIdivDiviSignedDivision"></a>DVI/IDIV/DIVI: Signed division</h3><div class="deeper">
Signed division can be accomplished by doing an unsigned division
and taking manually care of the negative-signs.
<p>Requirements:
</p><ul><li> Unsigned division
</li><li> Testing if value is negative
</li><li> Arithmetic negation
</li><li> Logical inversion
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">int_type    a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type    b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> sign </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">false</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    sign </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">!</span><span class="jSf6Z2BR2">sign</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Toggle the signed flag
	</span><span class="jSf6Z2BR2">    a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">a</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Negate a
	</span><span class="jSf9DH-K2">}
	</span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    sign </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">!</span><span class="jSf6Z2BR2">sign</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Toggle the signed flag
	</span><span class="jSf6Z2BR2">    b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Negate b
	</span><span class="jSf9DH-K2">}
	</span><span class="jSfnT6pa2">// a and b are both positive now
	</span><span class="jSf6Z2BR2">int_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">/</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Do unsigned division
	</span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">sign</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Negate the result
	</span><span class="jSf6Z2BR2">    result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">result</span><span class="jSf9DH-K2">;
	}</span></pre>
</div><h3><a name="MdiImodModiSignedModuloRemainder"></a>MDI/IMOD/MODI: Signed modulo (remainder)</h3><div class="deeper">
Signed modulo can be accomplished by calculating an unsigned modulo
and taking manually care of the negative-signs.
<p>Requirements:
</p><ul><li> Unsigned modulo
</li><li> Testing if value is negative
</li><li> Arithmetic negation
</li><li> Logical inversion
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">int_type    a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type    b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2"> sign </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">false</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    sign </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">!</span><span class="jSf6Z2BR2">sign</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Toggle the signed flag
	</span><span class="jSf6Z2BR2">    a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">a</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Negate a
	</span><span class="jSf9DH-K2">}
	</span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">b </span><span class="jSfoF-_93">&lt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Exception: Do NOT toggle the signed flag.
	</span><span class="jSf6Z2BR2">    b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Negate b
	</span><span class="jSf9DH-K2">}
	</span><span class="jSfnT6pa2">// a and b are both positive now
	</span><span class="jSf6Z2BR2">int_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">%</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// Do unsigned modulo
	</span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">sign</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfnT6pa2">// Negate the result
	</span><span class="jSf6Z2BR2">    result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">result</span><span class="jSf9DH-K2">;
	}</span></pre>
</div></div><h2><a name="Exponentiation"></a>Exponentiation</h2><div class="deeper">
From <a class="extlink" id="i91C3E1AD" href="https://en.wikipedia.org/wiki/Exponentiation_by_squaring">https://en.wikipedia.org/wiki/Exponentiation_by_squaring</a>
<p>Exponentiation is repeated multiplication.
For positive integer exponents:
</p><p>Requirements:
</p><ul><li> Multiplication
</li><li> Least significant bit test
</li><li> Binary bit-shift to right by 1
</li><li> Unsigned greater-than comparison
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_exponent</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type  b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_value</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	</span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&amp;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// A is odd?
	</span><span class="jSf6Z2BR2">    </span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    </span><span class="jSf9DH-K2">}
	</span><span class="jSf6Z2BR2">    b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">    a </span><span class="jSfoF-_93">&gt;&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// right-shift, i.e. divide by 2, round down
	</span><span class="jSf9DH-K2">}
	</span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
	</span><span class="jSf9DH-K2">{
	</span><span class="jSf6Z2BR2">    result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;
	}</span></pre>
<h3><a name="ExponentiationWithoutAnyBitOperations"></a>Exponentiation without any bit-operations</h3><div class="deeper">
If you do not have bit-shifts or bit-tests, the following algorithm can still be used:
<p>Requirements:
</p><ul><li> Multiplication
</li><li> Subtraction
</li><li> Unsigned greater-than comparison
</li><li> Random access memory or a stack
</li></ul><p>Note that you must know the upper limit of the exponents beforehand.
E.g. if your exponents are in range 0–9, you will need a stack of four slots
and four comparisons (1,2,4,8), but you do not need 16 or higher.
</p><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_exponent</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type  b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_value</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        int_type stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">4</span><span class="jSf9DH-K2">];
</span><span class="jSf6Z2BR2">        stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// b^1
</span><span class="jSf6Z2BR2">        stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// b^2
</span><span class="jSf6Z2BR2">        stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// b^4
</span><span class="jSf6Z2BR2">        stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">3</span><span class="jSf9DH-K2">]</span><span class="jSf6Z2BR2"> </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">          </span><span class="jSfnT6pa2">// b^8
	</span><span class="jSf6Z2BR2">int_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	</span><span class="jSfnT6pa2">// Repeat these lines for powers of two, according
	// to the upper limit of known value of A.
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">8</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">3</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">8</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">else</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* ignore stack[3] */</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">4</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">4</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">else</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* ignore stack[2] */</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">else</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* ignore stack[1] */</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> stack</span><span class="jSf9DH-K2">[</span><span class="jSfJnSXl1">0</span><span class="jSf9DH-K2">];</span><span class="jSf6Z2BR2">             </span><span class="jSf9DH-K2">}</span><span class="jSf6Z2BR2"> </span><span class="jSfWtbTI">else</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">/* ignore stack[0] */</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}</span></pre>
This algorithm is faster than a multiplication-loop for exponents larger than 4.
<p>It is not <em>necessary</em> to use the extra memory or stack or temporary variables, but then
you would need to recalculate the same values many times. It is still more efficient
than a multiplication loop if the multiplier is large enough and has few bits set.
</p><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_exponent</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type  b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_value</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type  result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
	</span><span class="jSfnT6pa2">// Repeat these lines for powers of two, according
	// to the upper limit of known value of A.
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">8</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> int_type tmp</span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b</span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2">b</span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b</span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2">b</span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b</span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2">b</span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> tmp</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">8</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">4</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> int_type tmp</span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b</span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2">b</span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b</span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2">b</span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">        result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> tmp</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">4</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">2</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2"> int_type tmp</span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> b</span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2">b</span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2">b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">               result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> tmp</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2">  </span><span class="jSfJnSXl1">2</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">}
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">if</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSfoF-_93">)</span><span class="jSf6Z2BR2"> </span><span class="jSf9DH-K2">{</span><span class="jSf6Z2BR2">                                      result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2">               </span><span class="jSf9DH-K2">}</span></pre>
A multiplication loop is the simplest and slowest option.
<p>Requirements:
</p><ul><li> Multiplication
</li><li> Subtraction
</li><li> Is-zero comparison
</li></ul><p></p><pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">uint_type a </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_exponent</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">uint_type b </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_value</span><span class="jSf9DH-K2">;

</span><span class="jSf6Z2BR2">        uint_type result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        </span><span class="jSfWtbTI">while</span><span class="jSfoF-_93">(</span><span class="jSf6Z2BR2">a </span><span class="jSfoF-_93">&gt;</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">0</span><span class="jSfoF-_93">)
</span><span class="jSf6Z2BR2">        </span><span class="jSf9DH-K2">{
</span><span class="jSf6Z2BR2">            result </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> result </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> b</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">            a      </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> </span><span class="jSfJnSXl1">1</span><span class="jSf9DH-K2">;
</span><span class="jSf6Z2BR2">        </span><span class="jSf9DH-K2">}</span></pre>
</div><h3><a name="OptimizationForConstantExponents"></a>Optimization for constant exponents</h3><div class="deeper">
If you know the exponent beforehand, there is a slightly
more efficient way to subdivide the exponentiation,
especially if the exponent is large.
<p>For example, with this algorithm quoted above,
n^15 evaluates into the following sequence of six multiplications:
</p><p></p><pre>     result = b          // b
     b = b*b             // b^2
     result = result * b // b^3 (b * b^2)
     b = b*b             // b^4
     result = result * b // b^7 (b^3 * b^4)
     b = b*b             // b^8
     result = result * b // b^15 (b^7 * b^8)
</pre>But n^15 can in fact be done with just five multiplications:
<p></p><pre>     result1 = b                // b
     result2 = result1*result1  // b^2
     result3 = result1*result2  // b^3
     result6 = result3*result3  // b^6
     result9 = result6*result3  // b^9
     result15 = result9*result6 // b^15
</pre>This works by recursively subdividing the exponent into two parts,
and is done automatically by e.g. GCC. The GCC source code gives
this reference for the algorithm:
<p></p><pre>   /* Expand power operator to optimal multiplications when a value is raised
      to an constant integer n. See section 4.6.3, "Evaluation of Powers" of
      Donald E. Knuth, "Seminumerical Algorithms", Vol. 2, "The Art of Computer
      Programming", 3rd Edition, 1998.  */
</pre>It features a 256-element lookup table.
For exponent <tt>n</tt>, this table gives value <tt>i = table[n]</tt>.
It means the following: <tt>x^n</tt> can be calculated as <tt>x^i * x^(n-i)</tt>.
<p>You can find the table in the GCC source code (search for “powi_table”),
or in that book, or alternatively you can use this C++ program to generate
the table in whichever size you desire: <a class="extlink" id="iE4D5E61C" href="http://bisqwit.iki.fi/jkp/powi-table-generator.cc">http://bisqwit.iki.fi/jkp/powi-table-generator.cc</a>
</p><p>The first 16 values of that table are:
0, 1, 1, 2, 2, 3, 3, 4, 4, 6, 5, 6, 6, 10, 7, and 9.
For exponent 15, this means x^9 * x^6. For exponent 9, this means x^6 * x^3.
And so on.
</p></div></div><h2><a name="Comparisons"></a>Comparisons</h2><div class="deeper">
<h3><a name="EqualityComparison"></a>Equality comparison</h3><div class="deeper">
Equality can be tested in various ways:
<p>Non-equality and inversion:
</p><pre>   result = !(a != b);
</pre>Less-than operation:
<pre>   result = !(a &lt; b) &amp;&amp; !(b &lt; a);
</pre>Subtraction and compare to zero:
<pre>   result = a-b; // Zero if equal
</pre>XOR and compare to zero:
<pre>   result = a^b; // Zero if equal
</pre></div><h3><a name="NonEqualityComparison"></a>Non-equality comparison</h3><div class="deeper">
Non-equality can be tested in various ways:
<p>Equality and inversion:
</p><pre>   result = !(a == b);
</pre>Less-than operation:
<pre>   result = a &lt; b || b &lt; a;
</pre>Subtraction and compare to zero:
<pre>   result = a-b; // Non-zero if equal
</pre>XOR and compare to zero:
<pre>   result = a^b; // Non-zero if equal
</pre></div><h3><a name="GreaterThanComparison"></a>Greater-than comparison</h3><div class="deeper">
Less-or-equal-than and inversion:
<pre>   result = !(a &lt;= b);
</pre>Less-than operation:
<pre>   result = b &lt; a;
</pre></div><h3><a name="GreaterOrEqualThanComparison"></a>Greater-or-equal-than comparison</h3><div class="deeper">
Less-than operation:
<pre>   result = !(a &lt; b);
</pre></div><h3><a name="LessThanComparison"></a>Less-than comparison</h3><div class="deeper">
Greater-or-equal-than and inversion:
<pre>   result = !(a &gt;= b);
</pre></div><h3><a name="LessOrEqualThanComparison"></a>Less-or-equal-than comparison</h3><div class="deeper">
Greater-than and inversion:
<pre>   result = !(a &gt; b);
</pre>Less-than operation:
<pre>   result = !(b &lt; a);
</pre></div></div><h2><a name="AppendixFloatingPointMathematicsCookbook"></a>Appendix: Floating-point mathematics cookbook</h2><div class="deeper">
Often you also need floating point mathematics, and if the hardware does not have
an integer multiplication unit, it most probably does not have floating point hardware
either.
<p>And if it does, it probably cannot calculate trigonometry at hardware level.
</p><p>The list of standard trigonometric functions provided by a floating
point math library may look intimidating, but a careful study reveals
fascinating equivalencies, that enable reducing nearly everything
into a set of just few functions: sqrt, log, exp and sin.
</p><h3><a name="ReducingComplicatedFunctionsIntoSimplerComponentsUsingComplexArithmetic"></a>Reducing complicated functions into simpler components using complex arithmetic</h3><div class="deeper">
When you operate using complex-number mathematics, everything can be reduced into sqrt, log and exp.
<p><table class="wikitable" border="1"><tbody><tr><th>  Operation</th><th>  Reduction</th><td>  Other equivalent functions</td></tr>
<tr><th>  asinh(x)</th><td>  log(x + sqrt(x² + 1)<em></em>)</td><td>  = −asinh(−x) <br> = −1 i*  asin(−1i*x) <br> = 1 i*asin(1i*x)</td></tr>
<tr><th>  acosh(x)</th><td>  log(x + sqrt(x² − 1)<em></em>)</td><td>  = 1 i*acos(x) when tan(arg(x)<em></em>) &gt; 0 <br> = −1 i*acos(x) when tan(arg(x)<em></em>) &lt; 0</td></tr>
<tr><th>  asin(x)</th><td>   1i *log(1i*(x + sqrt(x²−1)<em></em></td><td>  = −asin(−x)   <br> = −1 i*asinh(−1i*x) <br> = 1 i*asinh(1i*x)</td></tr>
<tr><th>  acos(x)</th><td>  −1 i *log(x + sqrt(x²−1)<em></em>)   or  −1i*log(x − sqrt(²−1)<em></em>)</td><td>   = 1 i*acosh(x) when tan(arg(x)<em></em>) &lt; 0 <br> = −1 i*acosh(x) when tan(arg(x)<em></em>) &gt; 0</td></tr>
<tr><th>  atanh(x)</th><td>  log( (1+x) / (1−x)<em></em>) / 2</td><td>  = i * atan(−1i * x) <br> = sometimes also −1i*atan(1i*x)</td></tr>
<tr><th>  atan(x)</th><td>  −0.5 i*log(<em></em>(1+1i*x) / (1−1i*x)<em></em>)</td><td>  = −1 i*atanh(1i*x)  <br> = sometimes also    1 i*atanh(−1i*x)</td></tr>
<tr><th>  sinh(x)</th><td>  0.5 * (exp(x) − exp(−x)<em></em>)</td><td>  = −sinh(−x) <br> = 1i*sin(−1i*x) <br> = −1i*sin(1i*x)</td></tr>
<tr><th>  cosh(x)</th><td>  0.5 *(exp(x) + exp(−x)<em></em>)</td><td>  = cosh(−x) <br> = cos(1i*x) <br> = cos(−1i*x)</td></tr>
<tr><th>  sin(x)</th><td>  0.5 i*(exp(x*−1i) − exp(x*1i)<em></em>)</td><td>  = −sin(−x) <br> = 1i*sinh(−1i *x) <br> = −1i*sinh(1i*x)</td></tr>
<tr><th>  cos(x)</th><td>  0.5  *(exp(x*−1i) − exp(x*1i)<em></em>)</td><td>  =  cos(−x) <br> = cosh(1i*x) <br> = cosh(−1i*x)</td></tr>
<tr><th>  tanh(x)</th><td>  sinh(x) / cosh(x) <br> = −1 * (1−exp( 2*x)<em></em>) / (1+exp( 2*x)<em></em>)</td><td>  = −tanh(−x) <br> = tan(1i*x)  <br> = −tan(−1i*x)</td></tr>
<tr><th>  tan(x)</th><td>  sin(x) / cos(x)     <br> =   1i * (1−exp(2i*x)<em></em>) / (1+exp(2i*x)<em></em>)</td><td>  = −tan(−x) <br> = tanh(1i*x) <br> = −tanh(−1i*x)</td></tr>
<tr><th>  sqrt(x)</th><td>  exp(0.5 * log(x)<em></em>)</td><td>  = pow(x,0.5)</td></tr>
<tr><th>  exp(x)</th><td></td><td>  = pow(e, x)      (where e is euler's constant)</td></tr>
<tr><th>  pow(x,y)</th><td>  exp(y * log(x)<em></em>)</td><td>  Note: If x is negative, log(x) will produce complex numbers.</td></tr>
<tr><th>  log10(x)</th><td>  log(x) / log(10)</td></tr>
<tr><th>  x/y</th><td></td><td>  = x * pow(y,-1) <br> = x * exp(-log(y)<em></em>)</td></tr>
</tbody></table></p></div><h3><a name="ImplementingComplexNumberFunctions"></a>Implementing complex-number functions</h3><div class="deeper">
<table class="wikitable" border="1"><tbody><tr><th>  Operation</th><th>  Equivalent function using real functions only</th><th>  What happens in special cases</th></tr>
<tr><th>  sin(x)</th><td>  sin(Xr)*cosh(Xi) + i*cos(Xr)*sinh(Xi)</td><td>  sin(Xr) if Xi=0 (duh)<br> i*sinh(Xi) if Xr=0</td></tr>
<tr><th>  cos(x)</th><td>  cos(Xr)*cosh(Xi) − i*sin(Xr)*sinh(Xi)</td><td>  cos(Xr) if Xi=0 <br> cos(Xi) if Xr=0</td></tr>
<tr><th>  sinh(x)</th><td>  sinh(Xr)*cos(Xi) + i*cosh(Xr)*sin(Xi)</td><td>  sinh(Xr) if Xi=0 <br> i*sin(Xi) if Xr=0</td></tr>
<tr><th>  cosh(x)</th><td>  cosh(Xr)*cos(Xi) + i*sinh(Xr)*sin(Xi)</td><td>  cosh(Xr) if Xi=0 <br> cos(Xi) if Xr=0</td></tr>
<tr><th>  tan(x)</th><td>  (sin(2*Xr) + i*sinh(2*Xi)<em></em>) / (cos(2*Xr) + cosh(2*Xi)<em></em>)</td><td>  tan(Xr) if Xi=0 <br> i*tanh(Xi) if Xr=0</td></tr>
<tr><th>  tanh(x)</th><td>  (sinh(2*Xr) + i*sin(2*Xi)<em></em>) / (cos(2*Xr) + cosh(2*Xi)<em></em>)</td><td>  tanh(Xr) if Xi=0 <br> i*tan(Xi) if Xr=0</td></tr>
<tr><th>  exp(x)</th><td>  exp(Xr)*cos(Xi) + i*exp(Xr)*sin(Xi)</td><td>  exp(Xr) if Xi=0 <br> i*sin(Xi) if Xr=0</td></tr>
<tr><th>  log(x)</th><td>  log(abs(X)<em></em>) + i * arg(X)</td><td>  log(Xr) if Xi=0 and Xr&gt;=0 <br> log(-Xr) − πi if Xi=0 and Xr&lt;0 (doesn't reduce into real) <br> -iπ/2 if Xr=0 and Xi&lt;0 <br> iπ/2 if Xr=0 and Xi&gt;0.</td></tr>
<tr><th>  abs(x)</th><td>  sqrt(Xr² + Xi²)</td><td>  Xr if Xi=0 <br> Xi if Xr=0</td></tr>
<tr><th>  arg(x)</th><td>  atan2(Xi,Xr)</td><td>  0 if Xi=0 and Xr&gt;0 <br> π if Xi=0 and Xr&lt;0 <br> -iπ/2 if Xr=0 and Xi&lt;0 <br> iπ/2 if Xr=0 and Xi&gt;0.</td></tr>
<tr><th>  atan(x)</th><td>   0.25i*log(<em></em>(Xr²+Xi²+2*Xi+1) / (Xr²+Xi² −2*Xi+1)<em></em>) + 0.5 *(atan2(Xr,Xi+1)+atan2(Xr,1−Xi)<em></em>)</td><td>  atan(Xr) if Xi=0</td></tr>
<tr><th>  atanh(x)</th><td>   0.25 *log(<em></em>(Xr²+Xi²+2*Xr+1) / (Xr²+Xi² −2*Xr+1)<em></em>) + 0.5i *(atan2(Xi,Xr+1)+atan2(Xi,1−Xr)<em></em>)</td><td>  atanh(Xr) if Xi=0</td></tr>
<tr><th>  x+y</th><td>  Xr + i*Xi + Yr + i*Yi</td></tr>
<tr><th>  x−y</th><td>  Xr + i*Xi − Yr − i*Yi</td></tr>
<tr><th>  x*y</th><td>  (Xr*Yr − Xi*Yi) + i*(Xi*Yr + Xr*Yi)</td><td>  i*i = −1</td></tr>
<tr><th>  x/y</th><td>  (Xr*Yr + Xi*Yi) / (Xr² + Yi²) + i*(<em></em>(Xi*Yr − Xr*Yi) / (Yr² + Yi²)<em></em>)</td></tr>
<tr><th>  sqrt(x)</th><td>  sqrt(<em></em>(abs(x) + Xr) / 2) + i*sgn(Xi)*sqrt(<em></em>(abs(x) − Xr) / 2) where sgn(n) <br> = -1, 0 or 1 depending on n's sign.</td></tr>
</tbody></table><p>It is especially interesting to see that complex-number sqrt, log and exp can
all be implemented in terms of real-number sqrt, log, exp, sin/cos and atan.
This defines the minimum set of floating point functions that must be implemented.
</p></div><h3><a name="ImplementingRealNumberFunctions"></a>Implementing real-number functions</h3><div class="deeper">
<table class="wikitable" border="1"><tbody><tr><th>  Operation</th><th>  Alternatives</th></tr>
<tr><th>  sin(x)</th><td>  −sin(−x) <br> cos(π/2 − x) <br> tan(x) * cos(x) <br> <a href="./bitwise_files/546ecab719ce73dfb34a7496c942972b.png"><img src="./bitwise_files/546ecab719ce73dfb34a7496c942972b.png" class="embed" alt="http://upload.wikimedia.org/math/5/4/6/546ecab719ce73dfb34a7496c942972b.png"></a> <br> Read: <a class="extlink" id="i74B980E8" href="http://en.wikipedia.org/wiki/Trigonometric">http://en.wikipedia.org/wiki/Trigonometric</a>_function, <a class="extlink" id="iBC965596" href="http://en.wikipedia.org/wiki/Taylor">http://en.wikipedia.org/wiki/Taylor</a>_series</td></tr>
<tr><th>  cos(x)</th><td>  cos(−x) <br> sin(π/2 − x) <br> sin(x) / tan(x)</td></tr>
<tr><th>  tan(x)</th><td>  −tan(−x) <br> sign(x) * sqrt(1 / cos(x)²-1) <br> sin(x) / cos(x)</td></tr>
<tr><th>  asin(x)</th><td>  −asin(−x) <br> π/2 − acos(x) <br> atan(x / sqrt(1 − x²)<em></em>) <br> <a href="./bitwise_files/11a93a7c7a5d23f74cdbab5a1e513123.png"><img src="./bitwise_files/11a93a7c7a5d23f74cdbab5a1e513123.png" class="embed" alt="http://upload.wikimedia.org/math/1/1/a/11a93a7c7a5d23f74cdbab5a1e513123.png"></a></td></tr>
<tr><th>  acos(x)</th><td>  π − acos(−x) <br> π/2 − asin(x) <br> π/2 − atan(x / sqrt(1 − x²)<em></em>) <br> asin(sqrt(1−x²)<em></em>) if 0&lt;=x&lt;=1</td></tr>
<tr><th>  atan(x)</th><td>  −atan(−x) <br> asin(x² / sqrt(x²+1)<em></em>) <br> 2 * atan(<em></em>(sqrt(1+x²) − 1) / x) <br> 2 * atan(x / (1 + sqrt(1 + x²)<em></em>)<em></em>) <br> atan(y) + atan(<em></em>(x−y)/(1+x*y)<em></em>) when sign(y)=sign(x) <br> <a href="./bitwise_files/c01ed76e4510e32f09a91f34660dcd78.png"><img src="./bitwise_files/c01ed76e4510e32f09a91f34660dcd78.png" class="embed" alt="http://upload.wikimedia.org/math/c/0/1/c01ed76e4510e32f09a91f34660dcd78.png"></a> <br> Read: <a class="extlink" id="i47DD00AB" href="http://en.wikipedia.org/wiki/Inverse">http://en.wikipedia.org/wiki/Inverse</a>_trigonometric_functions</td></tr>
<tr><th>  exp(x)</th><td>  pow(e, x) <br> cosh(x) + sinh(x) <br> cosh(−x) − sinh(−x) <br> pow(1 + x/y, y) when y approaches infinity <br> exp(x−y) * exp(y) for any y  <br> <a href="./bitwise_files/0bc08045195dc823c22d1fa283cb0759.png"><img src="./bitwise_files/0bc08045195dc823c22d1fa283cb0759.png" class="embed" alt="http://upload.wikimedia.org/math/0/b/c/0bc08045195dc823c22d1fa283cb0759.png"></a> <br> Read: <a class="extlink" id="iF60D002" href="http://en.wikipedia.org/wiki/Exponential">http://en.wikipedia.org/wiki/Exponential</a>_function</td></tr>
<tr><th>  log(x)</th><td>  log10(x) / log10(e) <br> log2(x) / log2(e) <br> asinh(<em></em>(x²+1) / (2*x)<em></em>) <br> acosh(<em></em>(x²−1) / (2*x)<em></em>) <br> 2*atanh(<em></em>(x−1) / (x+1)<em></em>) <br> log(x/y) + log(y) for any y&gt;0 <br> <a href="./bitwise_files/6dbf56b2e5f34d298c1e71ddd93b3448.png"><img src="./bitwise_files/6dbf56b2e5f34d298c1e71ddd93b3448.png" class="embed" alt="http://upload.wikimedia.org/math/6/d/b/6dbf56b2e5f34d298c1e71ddd93b3448.png"></a> <br> Read: <a class="extlink" id="iB5311396" href="http://en.wikipedia.org/wiki/Natural">http://en.wikipedia.org/wiki/Natural</a>_logarithm</td></tr>
<tr><th>  log2(x)</th><td>  log10(x) / log10(2) <br> log(x) / log(2)</td></tr>
<tr><th>  log10(x)</th><td>  log2(x) / log2(10) <br> log(x) / log(10)</td></tr>
<tr><th>  pow(x,y)</th><td>  1 / pow(x,−y) <br> exp(y*log(x)<em></em>) <br> if y is integer, a special algorithm may be applicable <br> always pay attention to special cases</td></tr>
<tr><th>  sqrt(x)</th><td>  pow(x,0.5) <br clear="all"> exp(0.5 * log(x)<em></em>) <br> Read: <a class="extlink" id="i1AD32307" href="http://en.wikipedia.org/wiki/Methods">http://en.wikipedia.org/wiki/Methods</a>_of_computing_square_roots, <a class="extlink" id="i157BCD65" href="http://en.wikipedia.org/wiki/Newton%27s">http://en.wikipedia.org/wiki/Newton%27s</a>_method</td></tr>
<tr><th>  sinh(x)</th><td>  −sinh(−x) <br> exp(x) − cosh(x) <br> cosh(x) − exp(−x) <br> 2*sinh(x/2)*cosh(x/2) <br> 1/2 * (exp(x) − exp(−x)<em></em>) <br> (exp(2*x)−1) / (2*exp(x)<em></em>) <br> tanh(x) * cosh(x) <br> <a href="./bitwise_files/43047f57ab3e2183d7875764566580f4.png"><img src="./bitwise_files/43047f57ab3e2183d7875764566580f4.png" class="embed" alt="http://upload.wikimedia.org/math/4/3/0/43047f57ab3e2183d7875764566580f4.png"></a></td></tr>
<tr><th>  cosh(x)</th><td>  cosh(−x) <br> exp(x) − sinh(x) <br> exp(−x) + sinh(x) <br> 1/2 * (exp(x) + exp(−x)<em></em>) <br> (exp(2*x)+1) / (2*exp(x)<em></em>) <br> sinh(x) / tanh(x) <br> <a href="./bitwise_files/84aa1c9392c1d950fc6ab5a51043fc02.png"><img src="./bitwise_files/84aa1c9392c1d950fc6ab5a51043fc02.png" class="embed" alt="http://upload.wikimedia.org/math/8/4/a/84aa1c9392c1d950fc6ab5a51043fc02.png"></a></td></tr>
<tr><th>  tanh(x)</th><td>  −tanh(−x) <br> (exp(2*x)−1) / (exp(2*x)+1) <br> sinh(x) / cosh(x) <br> <a href="./bitwise_files/a1635f7fd0e9e031ad7f92b27271226a.png"><img src="./bitwise_files/a1635f7fd0e9e031ad7f92b27271226a.png" class="embed" alt="http://upload.wikimedia.org/math/a/1/6/a1635f7fd0e9e031ad7f92b27271226a.png"></a></td></tr>
<tr><th>  asinh(x)</th><td>  log(x + sqrt(x² + 1)<em></em>) <br> 1/2 * acosh(2*x² + 1)</td></tr>
<tr><th>  acosh(x)</th><td>  log(x + sqrt(x² − 1)<em></em>) <br> 1/2 * acosh(2*x² − 1)</td></tr>
<tr><th>  atanh(x)</th><td>  1/2 * log(x+1) − 1/2 * log(1−x) <br> log( (1+x) / (1−x)<em></em>) / 2 <br> <a href="./bitwise_files/47383305b98c57bef4dad00d1490dd84.png"><img src="./bitwise_files/47383305b98c57bef4dad00d1490dd84.png" class="embed" alt="http://upload.wikimedia.org/math/4/7/3/47383305b98c57bef4dad00d1490dd84.png"></a></td></tr>
</tbody></table><p>Note: Even though more complicated trigonometric functions such as sinh() and atanh()
can be implemented in terms of the basic functions,
it may still be beneficial to implement them separately
using Taylor series for better accuracy.
</p></div><h3><a name="FloatingPointAddition"></a>Floating point addition</h3><div class="deeper">
TODO
</div><h3><a name="FloatingPointSubtraction"></a>Floating point subtraction</h3><div class="deeper">
TODO
</div><h3><a name="FloatingPointMultiplication"></a>Floating point multiplication</h3><div class="deeper">
<pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">int_type a_exponent </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1_exponent</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type a_mantissa </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1_mantissa</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2">     a_sign     </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1_sign</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type b_exponent </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2_exponent</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type b_mantissa </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2_mantissa</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2">     b_sign     </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2_sign</span><span class="jSf9DH-K2">;

	</span><span class="jSf6Z2BR2">int_type result_exponent </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1_exponent </span><span class="jSfoF-_93">+</span><span class="jSf6Z2BR2"> original_2_exponent</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type result_mantissa </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1_mantissa </span><span class="jSfoF-_93">*</span><span class="jSf6Z2BR2"> original_2_mantissa</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2">     result_sign     </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a_sign </span><span class="jSfoF-_93">^</span><span class="jSf6Z2BR2"> b_sign</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// XOR
	
	// After this, comes renormalization, which is the adjusting of
	// the exponent &amp; mantissa until the mantissa is in proper range.</span></pre>
</div><h3><a name="FloatingPointDivision"></a>Floating point division</h3><div class="deeper">
<pre class="source_snippet" style="background-color:#FFF;color:#000">	<span class="jSf6Z2BR2">int_type a_exponent </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1_exponent</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type a_mantissa </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1_mantissa</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2">     a_sign     </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1_sign</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type b_exponent </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2_exponent</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type b_mantissa </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2_mantissa</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2">     b_sign     </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_2_sign</span><span class="jSf9DH-K2">;

	</span><span class="jSf6Z2BR2">int_type result_exponent </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1_exponent </span><span class="jSfoF-_93">-</span><span class="jSf6Z2BR2"> original_2_exponent</span><span class="jSf9DH-K2">;
	</span><span class="jSf6Z2BR2">int_type result_mantissa </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> original_1_mantissa </span><span class="jSfoF-_93">/</span><span class="jSf6Z2BR2"> original_2_mantissa</span><span class="jSf9DH-K2">;
	</span><span class="jSf5gZog2">bool</span><span class="jSf6Z2BR2">     result_sign     </span><span class="jSfdoBI62">=</span><span class="jSf6Z2BR2"> a_sign </span><span class="jSfoF-_93">^</span><span class="jSf6Z2BR2"> b_sign</span><span class="jSf9DH-K2">;</span><span class="jSf6Z2BR2"> </span><span class="jSfnT6pa2">// XOR
	
	// After this, comes renormalization, which is the adjusting of
	// the exponent &amp; mantissa until the mantissa is in proper range.</span></pre>
</div></div></div><hr>
<div class="lastedit">
Last edited at: 2020-06-25T22:38:28+03:00</div>
 

</body></html>